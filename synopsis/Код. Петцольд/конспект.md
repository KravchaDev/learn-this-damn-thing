# Код. Тайный язык информатики. Чарльз Петцольд

ссылка на книгу: https://disk.yandex.ru/i/dYqvNneXXElg6w

Мой (Kravcha) комментарий к книге: 

> Очень хорошо разжёвываются все эти битности, разрядности и .тд. 
> Понравилось, что в процессе чтения вы, вместе с автором постепенно собираете компьютер и
> попутно осваиваете для этого необходимый бекграунд.

  ![](https://img.shields.io/badge/StackEditor-it%20is%20created%20there-blue?style=plastic&logo=github) ![](https://img.shields.io/badge/Habrastorage-posted%20pictures%20there-yellow?style=plastic&logo=habr) 
  ![](https://img.shields.io/badge/Sasha%20Bespoyasov-supported%20this-black?style=plastic) ![](https://img.shields.io/badge/Danila%20Kravchenko-structured%20and%20posted%20this-black?style=plastic)
___
![](https://img.shields.io/badge/reading%20time-~45%20mins-red?style=plastic&logo=coder)
## Глава 1. Верные друзья

Код — это система для обмена информацией между людьми и машинами, то есть средство коммуникации. Код полезен, если выполняет задачу, с которой не справляются другие коды.

> Звуки, издаваемые при произнесении слова, — это код, понятный любому, кто способен услышать наш голос и понимает язык, на котором мы говорим. Мы называем этот код речью. Для слов, изображаемых на бумаге, существует другой код — в виде написанных или на- печатанных символов. Мы называем этот код письмом или текстом

> Для общения люди используют множество различных кодов, потому что одни коды иногда удобнее других. Например, устную речь нельзя сохранить на бумаге, поэтому вместо нее мы применяем письмо

Читателей знакомят с кодированием информации через азбуку Морзе. В ней самые частые буквы кодируются самыми простыми и короткими символами:

![Таблица в направлении «буква алфавита → точки и тире азбуки Морзе»](https://habrastorage.org/webt/qd/nh/ww/qdnhwwkzkloq0qjoonret1r-vew.png)

Таблица в направлении «буква алфавита → точки и тире азбуки Морзе»

На письме азбука Морзе сводится ко двум символам. А…

> Два чего угодно способны в соответствующих комбинациях передать любую информацию

## Глава 2. Коды и комбинации

Чтобы воспринимать сообщение, написанное морзянкой, проще использовать не таблицу выше, а другую, в обратном направлении «точки и тире азбуки Морзе → буква алфавита».

![Диаграмма в направлении «точки и тире азбуки Морзе → буква алфавита»](https://habrastorage.org/webt/7r/ft/lu/7rftluekgr0y13ifyp7qytmbuou.png)

Диаграмма в направлении «точки и тире азбуки Морзе → буква алфавита»

Из неё можно увидеть, что количество букв, которые можно закодировать, равно двойке в степени, равной количеству точек или тире:

> Количество кодов = 2 Количество точек и тире

Значит, азбука Морзе — это двоичный код. Для двоичных кодов при подсчёте количества кодов используют степени 2.

## Глава 3. Брайль и двоичные коды

[В шрифте Брайля](https://ru.wikipedia.org/wiki/%D0%A8%D1%80%D0%B8%D1%84%D1%82_%D0%91%D1%80%D0%B0%D0%B9%D0%BB%D1%8F) символы кодируются комбинациями от одной до шести выпуклых точек, расположенных в ячейке размерами 2х3. Шрифт Брайля — тоже двоичный код.

> Любая точка может пребывать в одном из двух состояний: плоская или выпуклая

![Общее число комбинаций шести точек, каждая из которых может быть плоской или выпуклой, равно 2^6 = 64](https://habrastorage.org/webt/ma/ah/yh/maahyhfjvvllap0kdz-uy0dtc48.png)

Общее число комбинаций шести точек, каждая из которых может быть плоской или выпуклой, равно 2^6 = 64

Многие из кодов несут двойную нагрузку в зависимости от контекста: интервалов между кодами, особых _кодов переключений (shift codes)_ и _escape_-кодов.

> Код переключения меняет смысл всех следующих кодов, пока его действие не будет отменено

> Признак прописной буквы [_escape_-код, прим. автора конспекта] означает, что следующая за ним буква (и только она) должна интерпретироваться как прописная, а не строчная

К таким кодам часто прибегают при двоичном кодировании печатных символов.

## Глава 4. Анатомия фонарика

На примере фонарика рассмотрим действие электричества. Простейшая схема фонарика может быть такой:

![Батарейка, лампа и разомкнутый провод, который играет роль переключателя](https://habrastorage.org/webt/pz/li/jl/pzlijlqxhzkqdl0epg17gsjysf4.png)

Батарейка, лампа и разомкнутый провод, который играет роль переключателя

Чтобы лампочка загорелась, цепь должна быть _замкнутой_. Переключатель управляет замыканием и размыканием цепи. По замкнутой цепи «течёт» поток заряженных частиц, электронов, от одного атому к другому.

Батарейки «заставляют» электричество течь по цепи против часовой стрелки, если цепь замкнута.

> Химический состав батареек подобран так, что… на том конце батарейки, что помечен знаком «–», образуется избыток электронов, а на противоположном — …возникает их недостаток

> Чтобы возобновить реакцию, избыточным электронам на отрицательном полюсе батарейки нужно обеспечить проход к ее положительному полюсу. …Реакция происходит только при наличии замкнутой электрической цепи

Электричество течёт по проводу, который сделан из особого материала, который проводит электричество — проводника. Материалы, которые плохо проводят электричество называются изоляторами.

Проводники «сопротивляются» течению тока — обладают сопротивлением _(R)_. Чем выше сопротивление, тем меньше электронов течёт по цепи _(I)_. У батареек есть потенциальная способность к выполнению работы — напряжением _(U)_. Величины связаны законом Ома:

> I = U / R

Лампочка горит, потому что

> Если сопротивление провода невелико, он раскаляется и начинает светиться, поскольку электрическая энергия в нем преобразуется в тепловую

Переключатель отвечает за замкнутость цепи: выключен фонарик или нет, это тоже похоже на двоичный код.

## Глава 5. Там, за поворотом

Попробуем построить электрическую схему для устройства, похожего на телеграф:

![Когда переключатели соединены, соответствующая лампочка загорается; это позволяет передавать сообщения азбукой Морзе на расстоянии](https://bespoyasov.ru/img/blog/code-2-circuits.png)

Когда переключатели соединены, соответствующая лампочка загорается; это позволяет передавать сообщения азбукой Морзе на расстоянии

Или используя схему с заземлением:

![Здесь буквой V обозначается соединение батареи отрицательным контактом с землёй](https://habrastorage.org/webt/qe/jp/fs/qejpfsn9xmqqatoh2uekwxbtw3y.png)

Здесь буквой V обозначается соединение батареи отрицательным контактом с землёй

Чем длиннее провода, тем больше сопротивление, меньше ток, и тусклее светит лампа. Эта проблема относится и к настоящему телеграфу.

## Глава 6. Телеграф и реле

Мгновенная связь появилась относительно недавно и началась с телеграфа.

> …Суть электрического телеграфа проста: вы делаете нечто на одном конце провода, в результате чего на другом конце провода что-то происходит

Основа телеграфа — электромагнит. Замыкание переключателя на одном конце «включает» электромагнит на другом.

> Когда телеграфный ключ нажат, электромагнит тянет подвижный металлический молоточек вниз, и раздается звук одного тона («тик»). Когда ключ отпущен, электромагнит выключается, и молоточек возвращается в исходное положение, производя звук другого тона («так»). Быстрое чередование звуков («тик-так») соответствует точке, медленное — тире

![Схема телеграфа](https://habrastorage.org/webt/qe/jp/fs/qejpfsn9xmqqatoh2uekwxbtw3y.png)

Схема телеграфа

Провода тянуть бесконечно нельзя, поэтому приходится организовывать ретрансляцию — повторение сообщения для передачи дальше. Для этого используется реле.

![Схема реле: входящий ток приводит в действие электромагнит, тот притягивает гибкую металлическую полоску, а она замыкает цепь для выходящего тока](https://habrastorage.org/webt/lk/j0/g1/lkj0g10xrwyqrsaycjbukqg6vck.png)

Схема реле: входящий ток приводит в действие электромагнит, тот притягивает гибкую металлическую полоску, а она замыкает цепь для выходящего тока

## Глава 7. Великолепная десятка

Выбор десятичной системы счисления был произвольным. Но в десятичной системе (в отличие от той же римской) был ноль, который позволил использовать позиционную запись и облегчил умножение и деление.

Так как десятичная система позиционная, каждая цифра в записи числа — это количество соответствующих степеней десятки:

> 4825,8 = 4 * 103 + 8 * 102 + 2 * 101 + 5 * 100 + 8 * 10-1

А также:

> Преимущество позиционной записи не в том, что она хорошо работает в десятичной системе счисления, а в том, что она хорошо работает в системах счисления, основанных не на десяти

## Глава 8. Альтренативы десяти

В десятичной системе счисления круглыми числами мы считаем те, которые заканчиваются на 0: 10, 100, 1000… Такие числа — это произведение 10 на себя.

В других системах счисления круглые числа получаются по тому же принципу. В двоичной, например:

-   102 = 2 × 1
-   1002 = 2 × 2
-   10002 = 2 × 2 × 2

> В многозначном двоичном числе позиции цифр соответствуют степеням двойки

Провод, лампа и переключатель из прошлых глав тоже могут быть представлены в двоичном виде:

> Если по проводу течет ток, двоичная цифра равна 1. Если тока нет… 0

> Если переключатель включен, двоичная цифра равна 1. Если выключен… 0

> Если лампочка горит, двоичная цифра равна 1. Если не горит… 0

Двоичное число — это бит.

## Глава 9. За битом бит

Двоичная система счисления — простейшая система. Бит — одна двоичная цифра — это также минимально возможное количество информации.

Одиночный бит — это выбор из двух возможностей: да или нет. Всё, что можно свести к такому выбору, можно представить набором битов.

Чем больше битов используется, тем больше доступных вариантов выбора (кодов). В двоичной системе число кодов _(N)_ — это:

> N = 2b

…где _b_ — это число битов.

Чаще всего двоичный код в жизни можно увидеть на штрих-кодах. В битовом представлении срез штрих-кода выглядит так:

![Штрих-код представляет собой набор 95 битов; эти же цифры можно найти под штрих-кодом](https://bespoyasov.ru/img/blog/code-barcode.png)

Штрих-код представляет собой набор 95 битов; эти же цифры можно найти под штрих-кодом

Биты также играют роль в логике, где под 1 и 0 представляют истину и ложь.

## Глава 10. Логика и переключатели

Традиционная алгебра работает с числами, булева алгебра работает с множествами.

В булевой алгебре знак «+» (или _OR_) означает объединение множеств, символ «×» (или _AND_) означает пересечение множеств. В ней работают коммутативность, ассоциативность и дистрибутивность.

Пустое множество означается нулём, 0. Единица — полное множество, всё, о чём идёт речь. Для пересечения справедливо:

```
0 x 0 = 0
0 x 1 = 0
1 x 0 = 0
1 x 1 = 1

```

Для объединения:

```
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 1

```

Операцию пересечения можно представить в виде электрической цепи, где два переключателя соединены последовательно:

![Лампочка загорится лишь при одном условии: если вы включите левый и правый переключатели одновременно]

Лампочка загорится лишь при одном условии: если вы включите левый и правый переключатели одновременно

Для объединения подойдёт цепь с двумя параллельными переключателями:

![Лампа горит, если включен любой из переключателей](https://habrastorage.org/webt/ud/wz/1e/udwz1e9gmvmdy-cagpuuwyvr3ay.png)

Лампа горит, если включен любой из переключателей

## Глава 11. Вентили, которые не протекают

Соединение нескольких реле лежит в основе построения логических вентилей. Например, для построения _AND_:

![Лампочка загорится, только если замкнуть переключатели на обоих реле](https://habrastorage.org/webt/to/2g/ta/to2gta3falgi_ev8cmvb4cmdudg.png)

Лампочка загорится, только если замкнуть переключатели на обоих реле

Символически вентиль _AND_ обозначается так:

![Обозначение вентиля AND](https://habrastorage.org/webt/av/qp/xs/avqpxs6o4yjbdh11t4myj2xjjfm.png)

Обозначение вентиля AND

Если соединить реле параллельно, а не последовательно, получится вентиль _OR_, который обозначается так:

![Обозначение вентиля OR](https://habrastorage.org/webt/em/7x/ji/em7xjikkogy2ofaoghepnunneou.png)

Обозначение вентиля OR

Если же лампочка горит, когда переключатель разомкнут, и тухнет, когда переключатель замкнут, получится инвертор:

![Обозначение инвертора](https://bespoyasov.ru/img/blog/code-inversion.png)

Обозначение инвертора

Вентиль _NOR_ работает, как вентиль _AND_ с двумя инверторами на входах:

```
!A × !B = !(A + B)

```

Вентиль _OR_ с инвертированными входами — это _NAND_:

```
!A + !B = !(A × B)

```

Последние два выражения — это [законы де Моргана](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD%D1%8B_%D0%B4%D0%B5_%D0%9C%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B0). Они помогают упрощать цепи.

## Глава 12. Двоичный сумматор

Сложение — основное арифметическое действие, а также…

> Практически единственное действие, которое выполняют компьютеры

Таблицу сложения двоичных чисел удобно делить на две: таблицу разряда суммы и таблицу разряда переноса:
___
| Сумма | 0 | 1 |
|--|--|--|
| 0 | 0 | 1 |
| 1 | 1 | 0 |
_____
| Перенос | 0 | 1 |
|--|--|--|
| 0 | 0 | 0 |
| 1 | 0 | 1 |
____

Таблица переноса это работа вентиля _AND_, для работы суммы нам нужна схема _XOR_:

![Результат равен 1, если сигнал подаётся лишь на один из входов](https://habrastorage.org/webt/by/xm/w6/byxmw6woncmxjfwmuatmvlwly6u.png)

Результат равен 1, если сигнал подаётся лишь на один из входов

Обозначается эта схема так:

![Обозначение вентиля XOR](https://habrastorage.org/webt/bb/d-/f9/bbd-f9qkwvnpqybyfn7ebqiavyy.png)

Обозначение вентиля XOR

И тогда схема суммирования:

![Схема полусумматора](https://habrastorage.org/webt/qa/ns/yx/qansyxnfpcclnogqplmjijnitho.png)

Схема полусумматора

Это _полусумматор (half-adder)_. Называется он так, потому что он не прибавляет к сумме возможный разряд переноса от предыдущего суммирования. Чтобы сложить 3 двоичных цифры, нужны 2 полусумматора и вентиль OR:

![Схема полного сумматора (full-adder)](https://habrastorage.org/webt/jx/sh/5-/jxsh5-geszl9scqbwizz7tsycds.png)

Схема полного сумматора (full-adder)

## Глава 13. А как же вычитание?

Сперва научимся вычитать без заимствования из старшего разряда:

> 253 – 176 <=>  
> 253 – 176 + 1000 – 1000 <=>  
> 253 – 176 + 999 + 1 – 1000 <=>  
> 253 + (999 – 176) + 1 – 1000 <=>  
> 253 + 823 + 1 – 1000 <=>  
> 76 + 1 = 77

При вычитании двоичных чисел используется такой же метод, только вместо дополнения до 9, используется дополнение до 1.

Схема для вычитания будет такой:

![](https://habrastorage.org/webt/us/5r/mq/us5rmqojrsbt-48d17ef1e6xolg.png)

Если надо выполнить вычитание, сигнал Выч будет равен 1. При вычитании входы В инвертируются, а к результату сумматора прибавляется 1

Для записи отрицательных чисел используется дополнение до двух, когда отрицательные числа становятся после последнего возможного положительного числа:

```
0 00000000
1 00000001
…
126 01111110
127 01111111
-128 10000000
-127 10000001
…
-2 11111110
-1 11111111

```

Диапазон чисел: от -128 до +127, старший значащий бит — это знаковый разряд.

> Чтобы вычислить дополнение до двух, нужно посчитать дополнение до единицы и прибавить 1 или, что эквивалентно, инвертировать все цифры и прибавить 1

> Эта система позволяет выражать положительные и отрицательные числа без знака «минус», а также складывать положительные и отрицательные числа, используя только правила сложения

## Глава 14. Обратная связь и триггеры

Соединение с _обратной связью (feedback)_ — это соединение, в котором выход является также одним из его входов. _Триггер (flip-flop)_ — соединение, которое сохраняет информацию.

> Он снабжает электрическую схему памятью, в которой хранится информация о том, что в этой схеме происходило раньше

У простейшего триггера _(RS-триггера)_, два входа _S (set)_ и _R (reset)_. Он запоминает, какой из двух входов был последний раз под напряжением.

Триггер, который запоминает значение в конкретный момент времени, это D-триггер со _срабатыванием по уровню (data)_. Этот триггер запоминает один бит информации и хранит его для дальнейшего использования:

![](https://habrastorage.org/webt/zt/w_/7i/ztw_7ietroqatnetvr3v6ou2i1c.png)

Clock = «запомнить этот бит»; можно считать эту схему «памятью» в 1 бит

В таком триггере, если сигнал Данные изменится, пока сигнал _Clk_ равен 1, изменения будут отражаться на выходах _Q_ и _!Q_. Если мы хотим, чтобы выход менялся только, когда сигнал _Clk_ переходит из 0 в 1, то нам нужен триггер со _срабатыванием по фронту (edge-trigger)_:

![](https://habrastorage.org/webt/bl/ou/fs/bloufsrykom2s3nen6c11xz1bi0.png)

Первый блок работает как D-триггер, но содержимое входа Данные сохраняется, когда сигнал Clk равен 0. Выходы первого блока — это входы для второго, их содержимое сохраняется при обращении сигнала Clk в 1

Когда выход _!Q_ соединён со входом _D (data)_, а ко входу _Clk_ подведён осциллятор, мы получаем _делитель частоты (frequency divider)_. Он делит частоту осциллятора на 2. Выход делителя может быть совмещён со входом _Clk_ следующего делителя, тогда частота осциллятора будет делиться на 2количество делителей.

Если совместить подряд 3 делителя частоты…

![](https://habrastorage.org/webt/l8/sg/8q/l8sg8qb-qxhkzcrvxofdpbg7vu8.png)

Схема с тремя последовательно соединёнными делителями частоты

…И считать их выходы…

![](https://habrastorage.org/webt/x0/ec/9h/x0ec9hha1tc1nswk-657njvthsm.png)

Графики сигнала Clk и выходных сигналов каждого из делителей

…То получим схему, которая…

> считает в двоичном формате от 0 до максимального числа, зависящего от количества триггеров в схеме

## Глава 15. Байты и шестнадцатеричные числа

Байт — это (не открою Америки) 8 бит. Значения: от 00000000 до 11111111, 256 (28) вариантов, значения длинные, поэтому вместо двоичной записи можно использовать шестнадцатиричную.

> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, …

Тогда, например, 101101102 = B616.

## Глава 16. Сборка памяти

Бумага для людей — это основная внешняя память:

> Мы _пишем_, чтобы позже _прочитать_… Мы _сохраняем_ информацию, чтобы позже _использовать_ ее

D-триггер из прошлых глав, защёлка — это память размером в 1 бит. Мы можем переназвать выход _Q_ «выводом данных», а вход _Clk_ «записью». Из 8 таких защёлок, а также дешифратора 3 на 8 и селектора 8 на 1 мы получим _память с произвольным доступом (random access memory, RAM)_:

![](https://habrastorage.org/webt/ub/5m/lo/ub5mlorue929p0emjvk4l2kazlg.png)

Дешифратор с помощью адреса определяет, какой из входов под напряжением — в какую из защёлок идёт запись. Селектор определяет, сигнал с какого входа пойдёт на выход

Произвольный доступ означает, что читать и записывать значения можно в любой защёлке с помощью комбинации входов «Адрес».

При параллельном соединении двух _RAM_ 8×1 получим _RAM_ 8×2. При соединении с помощью селектора 2 на 1 и дешифратора 1 на 2 (как две отдельных «защёлки» внутри) — _RAM_ 16×1.

> Число значений в массиве _RAM_ = 2Количество входов «Адрес»

Память с произвольным доступом называют энергозависимой, потому что

> Для хранения информации ей требуется непрерывное энергоснабжение

## Глава 17. Автоматизация

Построим наконец компьютер™. Будем предполагать, что под защёлками всегда имеются в виду защёлки со срабатыванием по фронту (когда _Clk_ переходит из 0 в 1).

Подключим память _RAM_ к сумматору с накоплением суммы.

![](https://habrastorage.org/webt/ub/5m/lo/ub5mlorue929p0emjvk4l2kazlg.png)

Схема с памятью, сумматором с накоплением и пультом управления для ввода значений

Допустим, нужно найти три суммы. Представим в памяти слагаемые и адреса значений:

![](https://habrastorage.org/webt/wj/oa/ha/wjoahamkiapxdpu9ao8bk4tx3ns.png)

Массив RAM со значениями для суммирования

Для сложения сумматор теперь должен:

> …Переписать [загрузить] содержимое ячейки памяти в аккумулятор. …Сложить байт из памяти с содержимым аккумулятора. …Сохранить в памяти сумму из аккумулятора. …Остановить работу сумматора

Для массива из рисунка выше:

> -   загрузить значение из ячейки 0000h в аккумулятор;
> -   сложить значение из ячейки 0001h с аккумулятором;
> -   сложить значение из ячейки 0002h с аккумулятором;
> -   сохранить значение из аккумулятора в ячейке 0003h;
> -   загрузить значение из ячейки 0004h в аккумулятор;
> -   сложить значение из ячейки 0005h с аккумулятором;
> -   сохранить значение из аккумулятора в ячейке 0006h;
> -   загрузить значение из ячейки 0000h в аккумулятор;
> -   сложить значение из ячейки 0001h с аккумулятором;
> -   сложить значение из ячейки 0002h с аккумулятором;
> -   сохранить значение из аккумулятора в ячейке 0003h;
> -   остановить работу

Чтобы этого добиться, каждое число в памяти сопроводим кодом нужного действия. Этим будет заниматься отдельный массив _RAM_ («коды»), в который мы запишем нужные действия:

![](https://habrastorage.org/webt/xt/vq/ak/xtvqakiytsb1feq6hiqpm0e5fvm.png)

Массив RAM «коды» с записанными действиями для автоматического сумматора

«Данные» и «коды» можно объединить в один массив, но чтобы было удобнее работать с адресами команд, стоит добавить команду «Перейти», которая укажет на адрес следующей команды для выполнения.

Также добавим _флаг нуля (zero flag)_, выход которого равен 1, лишь если всего его входы равны нулям. С ним мы можем добавить ещё 4 команды. Итого сейчас есть коды команд:

| **Загрузить** | 10h | LOD |
|--|--|--|
| **Сохранить** | 11h | STO |
| **Сложить** | 20h | ADD |
| **Вычесть** | 21h | SUB |
| **Сложить с переносом** | 22h | ADC |
| **Вычесть с заимствованием** | 23h | SBB |
| **Перейти** | 30h | JMP |
| **Перейти, если 0** | 31h | JZ |
| **Перейти, если перенос** | 32h | JC |
| **Перейти, если не 0** | 33h | JNZ |
| **Перейти, если не перенос** | 34h | JNC |
| **Остановитьс** | FFh | HLT |


Этих команд хватит, чтобы перемножить два числа друг на друга:

![](https://habrastorage.org/webt/u7/vo/1h/u7vo1hhwxwtqx0ptmy11zb3ib1o.png)

Массив памяти с инструкциями к перемножению чисел

Чтобы провести эти операции, потребуется схема:

![](https://habrastorage.org/webt/ml/7h/84/ml7h84mfcshkv3cmd4gsp0itqam.png)

Схема примитивного компьютера

> возможность управляемых _циклических_ процедур отличает компьютер от калькулятора

В схеме выше память — это 64-килобайтовый массив _RAM_. Ввод и вывод — переключатели и лампочки на пульте управления памятью. Всё остальное — 8-разрядный _процессор (central processing unit, CPU)_.

С помощью мнемоник, команды можно записывать в виде:

```
LOD A, [1003h]
(1) Загрузить;
(2) Куда A — в аккумулятор;
(3) Откуда [1003h] — из ячейки 1003h.

STO [1003h], A
(1) Сохранить;
(2) Куда — по адресу 1003h;
(3) Откуда — из аккумулятора.

JNZ 0000h
(1) Перейти, если флажок нуля не равен 1;
(2) Куда — к команде по адресу 0000h.

1000h: 00h, A7h
(!) Данные: младший и старший байты.

```

Далее, так как:

> При написании кодов численные значения адресов лучше не использовать, так как они могут измениться… Для обозначения ячеек памяти предпочтительнее пользоваться метками (labels)

Добавим метки, получим «ассемблер». Вот программа для умножения чисел:

```
BEGIN:  LOD A, [RESULT + 1]
        ADD A, [NUM1 + 1]
        STO [RESULT + 1], A

        LOD A, [RESULT]
        ADC A, [NUM1]
        STO [RESULT], A

        LOD A, [NUM2 + 1]
        ADD A, [NEG1]
        STO [NUM2 + 1], A

        JNZ BEGIN

NEG1:   HLT

NUM1:   00h, A7h
NUM2:   00h, 1Ch
RESULT: 00h, 00h

```

## Глава 18. От счетов к микросхемам

Реле для создания компьютеров не подходят, и в XX веке их заменили радиолампы:

> Будучи механическими устройствами, действие которых основывалось на изгибании металлической пластины, после продолжительной работы они в самом прямом смысле слова ломались

Компьютер, который мы собрали ранее, — типичный пример архитектуры фон Неймана. Её недостаток в долгой загрузке из памяти.

В 1947 году появился полупроводниковый транзистор. Полупроводники — это элементы, проводимостью которых можно управлять (например, кремний). Если в полупроводнике есть избыточные электроны, это полупроводник n-типа, в обратном случае — p-типа.

Транзистор состоит из полупроводниковых элементов: коллектора, базы и эмиттера.

![](https://habrastorage.org/webt/l_/up/qj/l_upqjch3be82q8loz4tioosklo.png)

Небольшое напряжение на базе управляет гораздо большим током, проходящим из коллектора в эмиттер. Если на базе напряжения нет, транзистор практически закрывается

Транзисторы подходят для сборки логических вентилей:

![](https://habrastorage.org/webt/1f/95/h1/1f95h1pex0xfksrdxxoatziazpo.png)

Вентили AND и OR, собранные из транзисторов

В интегральных микросхемах умещаются сразу логические схемы. Например, в «счетверенной двухвходовой положительной схеме _NAND»_ было 4 вентиля _NAND_:

![](https://habrastorage.org/webt/vf/bo/ap/vfboapmpjgb8czdbvkfpp_hrwz8.png)

Vcc — питающее напряжение, Gnd — земля

> Напряжения в диапазоне 0–0,8 В считаются логическим нулем, а напряжения от 2 до 5 В — логической единицей. …Так микросхемы защищаются от шума

Время установки — между изменением сигнала на входе и на выходе — измеряется в наносекундах.

Для осциллятора используется кварцевый кристалл, частота их колебаний более миллиона в секунду, это влияет на быстродействие.

## Глава 19. Два классических микропроцессора

В этой главе автор в подробностях описывает принцип работы процессоров _Intel 8080_ и _Motorolla 6800_. Я приведу здесь лишь сокращённое описание 8080, там самая мякотка.

Начнём со схемы:

![](https://habrastorage.org/webt/jk/xa/dg/jkxadgbh_mfwi-3vrftiunl_tdg.png)

Назначение каждого из 40 выводов микропроцессора 8080

-5В, 5В и +12В — это питание с напряжением соответственно -5, 5 и +12 вольт, _GND_ — земля. Направление стрелок на других выводах указывает направление сигнала, некоторые выводы работают в обе стороны.

Зачёркнутые нули — это синхронизирующие сигналы. От A0 до A15 — адресация памяти. С D0 до D7 — для данных. Остальное — управляющие сигналы.

У 8080 процессора 244 команды «как же я люблю их, вот они».

```
32 STA (сохранить из аккумулятора)
3A LDA (загрузить в аккумулятор)

```

Кроме аккумулятора есть 6 регистров B, C, D, E, H, L. H и L — это _High_ и _Low_. 8-битовый значения в регистрах _HL_ рассматриваются как 16-битовая пара, где старший байт хранится в H, а младший в L. Регистры позволяют не обращаться постоянно к памяти, что ускоряет работу.

63 кода отведено под команд _MOV_ — для перемещения содержимого из одного регистра в другой.

```
40 MOV B, B
41 MOV B, C (Из регистра C в B)
…
5E MOV E, [HL] (Из HL в E)
5F MOV E, A
60  MOV H, B
…
68  MOV L, B
…
70  MOV [HL], B
…
76  HLT
…
7F  MOV A, A

```

_MVI_ — перемещает непосредственно байт данных в регистр или ячейку памяти, адрес которой записан в _HL_.

Для арифметических действий есть 32 команды. Сложение _(ADD)_, сложение с переносом _(ADC)_, вычитание _(SUB)_, вычитание с заимствованием _(SBB)_.

```
80  ADD A, B
…
88  ADC A, B
…
90 SUB A, B
…
98 SBB A, B
…
9F SBB A, A

```

Есть также команды для логических операций. _AND_, _OR_ и _XOR_ выполняются побитово. _CMP_ — сравнение:

```
A0 AND A, B
…
A8 XOR A, B
…
B0 OR A, B
…
B8 CMP A, B
…
BF CMP A, A

```

_CMA_ — дополняет содержимое аккумулятора до 1. _DAA_ — для арифметических операций с десятичными числами в _BCD (Binary-coded decimal)_. _BCD_ — это когда _27h_ значит 27 в десятичной, а не 39.

Команды для увеличения и уменьшения значения регистров, аккумулятора или ячейки памяти на 1: _INR_, _DCR_. 4 команды для циклического сдвига: _RLC_, _RRC_, _RAL_, _RAR_. Команды для работы со стеком: _PUSH_, POP_.

_CALL_ и _RET_ — команды для создания подпрограмм. Команда _CALL_ записывает в стек адрес команды, стоящей следом за командой _CALL_, а потом происходит переход в начало подпрограммы с меткой _Multiply_. По завершении выполняется команда _RET_, в результате чего в программный счетчик возвращается значение из стека.

(Кстати, именно в этой книге я-таки наконец полностью понял, что такое «стек вызова» и почему именно _return_ стоит в конце функции.)

Команды _IN_ и _OUT_ — для общения с периферией.

## Глава 20. ASCII — символы нашего времени

[Американский стандартный код для обмена информацией](https://ru.wikipedia.org/wiki/ASCII) _(American Standard Code for Information Interchange, ASCII)_ — 7-битовая (технически) текстовая кодировка. Её коды принимают значения от _00h_ до _7Fh_. Для хранения отдельных символов отводится 8 битов.

В _ASCII_ содержатся знаки препинания, цифры, прописные и строчные буквы и управляющие символы. я отдельных символов отводится 8 битов. Коды строчных букв отличаются от соответствующих прописных на _20h_, это позволяет относительно просто переводить строчные в прописные и обратно.

Для того, чтобы закодировать что-то кроме латиницы, появился _Unicode_. В ней символы занимают по 2 байта, первые 128 символов совпадают с _ASCII_.

## Глава 21. Под шорох шин

Интегральные схемы, из которых состоит компьютер, монтируются на платах. Платы обмениваются информацией через шину. Сигналы на ней делятся на 4 категории:

-   Адресные — для адресации оперативной памяти или обращения к другим устройствам.
-   Вывода данных — для передачи данных в память и на другие устройства.
-   Ввода данных — генерируются различными устройствами компьютера и поступают в микропроцессор.
-   Управляющие — генерируются как микропроцессором, так и другими устройствами, которым нужно что-то сообщить процессору.

> Шина во всеобщем пользовании может стать стандартом

> Шины приходится модернизировать или заменять, когда микропроцессоры перерастают их либо по разрядности данных, либо по объему адресуемой памяти, либо по быстродействию

Ещё в этой главе есть рассказ о дискетах и катодно-лучевой трубке! 😃

> Луч начинает свое путешествие в верхнем левом углу. Пройдя вправо до конца экрана, он возвращается назад и начинает рисовать следующую строку развертки

> Закончив последнюю строку, луч возвращается из нижнего правого в верхний левый угол экрана

Чтобы вывести текст на экране, надо символы _ASCII_ отобразить в виде чёрных и белых пикселей на экране. Генератор символов переводит 7-битовый код _ASCII_ в 64-битовый код, определяющий внешний вид символа:

![](https://habrastorage.org/webt/xg/ca/wp/xgcawpch3he_3cnr9hfrkzwgfbm.png)

Каждому символу соответствует не только 7-битовый код ASCII, но и 64 бита на экране, которые определяют его внешний вид

Чтобы раскрасить пиксель, надо увеличить количество битов, на него отведённое:

> Количество цветов = 2Количество битов на пиксель

## Глава 22. Операционная система
Нашему компьютеру не достаёт двух вещей:

-   программного обеспечения (ПО);
-   избавиться от пульта управления, которым мы вводили команды в виде двоичных кодов, и добавить клавиатуру.

Для работы клавиатуры нам нужна специальная программа — обработчик клавиатуры, а также командный процессор.

Кроме этого нам потребуется ПЗУ — постоянное запоминающее устройство, чтобы введённая информация не терялась после отключения питания. В качестве ПЗУ можно использовать жёсткий диск.

> Вам придется помнить, что и куда вы сохранили… часть места на диске, вероятно, занята другими данными, сектора с одной и той же программой не обязательно будут следовать друг за другом

> Сидеть перед компьютером и продолжать записывать на бумажке адреса секторов и отмечать, что в них сохранено, — слишком трудоемко. …[Настало время] разработки файловой системы

Файловая система — организация информации, когда она делится на файлы. Файл — набор данных с общим смыслом, записанный в одном или нескольких секторах.

Забавный факт о названиях файлов в и размере расширения в 3 символа:

> Имя файла в CP/M состоит из двух частей. Первая часть — собственно имя файла (filename) длиной до 8 символов… Длина второй — типа файла (file type) — ограничена тремя символами…

Чтобы запустить операционную систему, её нужно переписать с диска в память — загрузить. В конце загрузки ОС полностью размещается в памяти, занимая её старшие адреса.

Прикладным программам (приложениям) не нужно заботиться о дорожках и секторах на диске при наличии ОС — _интерфейса прикладного программирования, API_.

_API_ аппаратно независим. То есть при написании программ для _CP/M_ нам не надо знать, как работают клавиатура, монитор и диск на конкретном компьютере.

## Глава 23. Фиксированная точка, плавающая точка

Мы привыкли думать о непрерывном ряде чисел, но компьютеры работают с дискретными величинами.

Чтобы записать дробь, мы можем использовать фиксированную точку — отвести конкретное количество бит под десятичные числа. В таком случае десятичный разделитель всегда находится в определённом месте числа.

> Формат с фиксированной точкой хорош, если вы знаете, что числа не «перерастут» ту область памяти, которую вы для них отвели

В обратном случае, под такие числа придётся резервировать слишком много места в памяти. Чтобы записывать числа, которые могут быть и очень большими, и очень маленькими используется плавающая точка.

В числах плавающей точкой используется научная нотация чисел со значащей частью и порядком. Но так как мы работаем с двоичными числами, то и порядок будет указывать на степень 2, а не 10.

В нормализованном виде слева от разделителя всегда стоит единица:

> 1.01 × 22 1.101 × 22

В большей части компьютеров для чисел с плавающей точкой используется стандарт _IEEE_, [Standard 754 Floating Point Numbers](https://en.wikipedia.org/wiki/IEEE_754-1985). В нём есть 2 формата: с простой точностью (_single precision_, 4 байта на число) и двойной точностью (_double precision_, 8 байтов на число).

Точность числа с фиксированной точкой легко определить по внешнему виду: сколько чисел после запятой, такая и точность. С плавающей — ¯\_(ツ)_/¯

> В зависимости от порядка число с плавающей точкой может быть точным до долей пенса или до нескольких тысяч долларов

> …С точки зрения программы 262 144,00 долларов не отличаются от 262 144,01 долларов… Действительно, оба числа представляются в компьютере так: 1.00000000000000000000000 × 218

## Глава 24. Языки высокие и низкие


> Программировать в машинных кодах — все равно что есть зубочисткой

Первым делом стоит автоматизировать перевод из команд мнемокодов (_MOV_, _MVI_ и прочие) в настоящие коды команд. Этим занимаются ассемблеры.

> Новый ассемблер приходится разрабатывать каждый раз при появлении нового процессора

У программ-ассемблеров два недостатка:

-   писать их — кропотливо;
-   они не переносимые: нельзя написать ассемблер для одного процессора и использовать его с другим.

Язык ассемблера считается языком низкого уровня, потому что он напрямую взаимодействует с оборудованием компьютера. Языки высокого уровня этим не занимаются.

Для работы языку высокого уровня нужен синтаксис и компилятор или интерпретатор. Первый — набор правил для построения выражений; второй — программа, которая преобразует код в машинные коды.

Далее в этой главе есть несколько примеров программирования на Алголе и Бейсике, здесь я их приводить не буду, но по фану почитать интересно.

## Глава 25. Графическая революция[](https://bespoyasov.ru/blog/code-the-hidden-language-of-computer-hardware-and-software-2/#глава25-графическая-революция)

Чтобы получить на экране электронно-лучевой трубки цвет, приходится использовать уже не одну, а три электронные пушки, по одной для каждого из основных цветов — красного, зеленого, синего.

Таблица кодирования цветов для адаптера дисплея может быть такой:
|Биты|Цвет|
|--|--|
|000|Черный|
|001|Синий|
|010|Зеленый|
|011|Голубой|
|100|Красный|
|101|Малиновый|
|110|Желтый|
|111|Белый|

Количество достпуных цветов выражается:

> Число цветов = 2 Число битов на пиксель

Чтобы работать со звуком, нужны преобразователи:

-   ЦАП, цифро-аналогоавый — для преобразования электрического сигнала в звук;
-   АЦП, аналогово-цифровой — для преобразования звука в электрический сигнал.

> Частота, с которой аналоговый звуковой сигнал преобразуется в цифровой, называется частотой дискретизации

